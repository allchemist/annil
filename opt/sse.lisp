(in-package :annil)

(export '(sse-compute-slopes sse-compute-errors optimize-sse))

(defun sse-compute-slopes (weights slopes patterns act-fn deriv-fn deriv-offset)
  (let ((lgrad (make-matrix (patterns-output-dim patterns)))
	(out (make-matrix (patterns-output-dim patterns)))
	(err 0.0))
    (do-patterns-safe (patterns p)
      (map-matrix (gemv weights (first p) :dest out) act-fn)
      (m- (copy out lgrad) (second p))
      (incf err (square (e-norm lgrad)))
      (m* lgrad
	  (let ((deriv (map-matrix (copy out) deriv-fn)))
	    (when deriv-offset (m+c deriv deriv-offset))
	    deriv))
      (m+ slopes (ger lgrad (first p))))
    (values slopes err)))

(defun sse-compute-errors (weights patterns act-fn)
  (let ((out (make-matrix (patterns-output-dim patterns)))
	(err 0.0))
    (do-patterns-safe (patterns p)
      (map-matrix (gemv weights (first p) :dest out) act-fn)
      (m- out (second p))
      (incf err (square (e-norm out))))
    err))

(defun optimize-sse (weights patterns test-part act-fn params)
  (let ((deriv-fn (deriv-fn-name act-fn))
	(method (or (param params :method) :quickprop))
	train test)
    (if (or (null test-part) (zerop test-part))
	(setf train patterns)
	(progn (do-patterns-shuffle (patterns p)
		 (when (< (random 1.0) test-part)
		   (push p test)
		   (push p train)))
	       (setf train (coerce train 'simple-vector)
		     test (coerce test 'simple-vector))))
    (flet ((slopes-fn (w s)
	     (sse-compute-slopes w s train act-fn deriv-fn (param params :deriv-offset)))
	   (err-fn (w)
	     (sse-compute-errors w test act-fn)))
      (funcall (intern (string method) :annil)
	       weights #'slopes-fn #'err-fn train test params))))
