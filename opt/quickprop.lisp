(in-package :annil)

(defun quickprop-update (d s ps eps mu shrink-factor)
  "Quickprop update rule, choose linear or quadratic estimate out of slope size"
  (let ((step 0.0))
    (cond ((minusp d)
	   (when (plusp s)
	     (decf step (* eps s))) 
	   (if (>= s (* shrink-factor ps))
	       (incf step (* mu d))
	       (incf step (* d (/ s (- ps s))))))
	  ((plusp d)
	   (when (minusp s)
	     (decf step (* eps s)))
	   (if (<= s (* shrink-factor ps))
	       (incf step (* mu d))
	       (incf step (* d (/ s (- ps s))))))
	  (t (decf step (* eps s))))
    step))

(defun qp-compute-errors (input output goal deriv-fn deriv-offset slopes)
  (let* ((lgrad (m- (copy output) goal))
	 (err (square (e-norm lgrad))))
    (m* lgrad
	(let ((deriv (map-matrix (copy output) deriv-fn)))
	  (when deriv-offset (m+c deriv deriv-offset))
	  deriv))
    (m+ slopes (ger lgrad input))
    err))

;; params: :iter, :eps, :mu, :thr, :recomute, :deriv-offset, :verbosity

(defun quickprop-sse (weights train-patterns test-patterns act-fn init-params)
  (flet ((w-like () (make-matrix-like weights)))
    (let ((prev-slopes (w-like))
	  (params (copy-tree init-params))
	  (num-patterns (num-patterns train-patterns))
	  (epoch-err most-positive-fixnum)
	  (prev-epoch-err nil)
	  (test-err most-positive-fixnum)
	  (prev-test-err nil)
	  (epochs-passed 0)
	  (verbosity (param init-params :verbosity))
	  (recompute-limit (param init-params :recompute))
	  (act-fn-deriv (deriv-fn-name act-fn))
	  (deriv-offset (param init-params :deriv-offset))
	  (thr (or (param init-params :thr) 0.0)))
      ;; parameters checking
      (assert (typep (param params :iter) 'fixnum) nil "Number of iterations not integer")
      (when (or (not (typep verbosity 'fixnum))
		(minusp verbosity))
	(setf verbosity 0))
      (when (> verbosity 3) (setf verbosity 3))
      (unless (param params :eps)
	(when (>= verbosity 3) (info "Using default parameter: eps = 0.1~%"))
	(setf (param params :eps) 0.1))
      (unless (param params :mu)
	(when (>= verbosity 3) (info "Using default parameter: mu = 2.0~%"))
	(setf (param params :mu) 2.0))
      (unless recompute-limit
	(when (>= verbosity 3) (info "Using unlimited recomputation limit~%")))
      ;; main loop
      (dotimes (i (param params :iter))
	(incf epochs-passed)
	(let ((slopes (w-like))
	      (delta-weights (w-like))
	      (eps (/ (param params :eps) num-patterns))
	      (mu (param params :mu))
	      (shrink-factor (/ (param params :mu) (1+ (param params :mu)))))
	  
	  (setf prev-epoch-err epoch-err)
	  (setf epoch-err 0.0)
	  (do-patterns (train-patterns p)
	    (let ((out (eval-layer (first p) weights act-fn)))
	      (incf epoch-err (qp-compute-errors (first p) out (second p) act-fn-deriv deriv-offset slopes))))

	  (map-three-matrices delta-weights slopes prev-slopes
			      #'(lambda (d s ps)
				  (quickprop-update d s ps eps mu shrink-factor)))
	  (m+ weights delta-weights)
	  (setf prev-slopes slopes)
	  (setf epoch-err (/ epoch-err num-patterns))
	  (when test-patterns
	    (setf prev-test-err test-err
		  test-err (sse-patterns-layer-error test-patterns weights act-fn)))
	  (when (>= verbosity 3)
	    (if test-patterns
		(info "Current error: ~A, over test patterns: ~A~%" epoch-err test-err)
		(info "Current error: ~A~%" epoch-err)))
	   (when recompute-limit
	    (if	(if test-patterns
		    (<= prev-test-err (* (1+ thr) test-err))
		    (<= prev-epoch-err (* (1+ thr) epoch-err)))
		(decf (param params :recompute))
		(when (< (param params :recompute) recompute-limit)
		  (incf (param params :recompute))))
	    (when (minusp (param params :recompute))
	      (when (>= verbosity 1) (info "Stagnant at ~A epoch~%" i))
	      (return)))))
      (when (>= verbosity 1)
	(if test-patterns
	    (info "Final error: ~A, over test patterns: ~A~%" epoch-err test-err)
	    (info "Final error: ~A~%" epoch-err)))
      (values weights epoch-err epochs-passed))))
