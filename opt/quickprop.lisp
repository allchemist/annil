(in-package :annil)

(defun quickprop-sse
 (weights patterns act-fn iter init-params)
  (let ((delta-weights (make-matrix-like weights))
	(slopes (make-matrix-like weights))
	(prev-slopes (make-matrix-like weights))

	(out (make-matrix (patterns-output-dim patterns)))
	(lgrad (make-matrix (patterns-output-dim patterns)))
	(prev-err most-positive-fixnum)
	(epoch-err 0)
	(params (copy-tree init-params))
;	(recompute-limit (param init-params :recompute))
	(num-patterns (num-patterns patterns))
	(act-fn-deriv (deriv-fn-name act-fn)))
    (dotimes (i iter)
      (let* ((eps (/ (param params :epsilon) num-patterns (patterns-input-dim patterns)))
	     (mu (param params :mu))
	     (shrink-factor (/ mu (1+ mu))))
	(do-patterns-shuffle (patterns p)
	  (map-matrix (gemv weights (first p) :dest out) act-fn)
	  (m- (copy out lgrad) (second p))
	  (incf epoch-err (msum (map-matrix-square (copy lgrad))))
	  (m* lgrad (map-matrix out act-fn-deriv))
	  (ger lgrad (first p) :dest slopes)
	  
	  (map-three-matrices delta-weights slopes prev-slopes
			      #'(lambda (d s ps)
				  (let ((step 0.0))
;				    (when (< (* d s) 0)
;				      (decf step (* eps s)))
;				    (if (< (* d (- s (* shrink-factor ps))) 0)
;					(incf step (* mu d))
;					(incf step (* (/ s (- ps s)) d)))
				    (cond ((minusp d)
					   (when (plusp s)
					     (decf step (* eps s))) 
					   (if (>= s (* shrink-factor ps))
					       (incf step (* mu d))
					       (incf step (* d (/ s (- ps s))))))
					  ((plusp d)
					   (when (minusp s)
					     (decf step (* eps s)))
					   (if (<= s (* shrink-factor ps))
					       (incf step (* mu d))
					       (incf step (* d (/ s (- ps s))))))
					  (t (decf step (* eps s))))
				    step)))
	  (m+ weights delta-weights)
	  (copy slopes prev-slopes)
	  (m- slopes slopes))

	(setf epoch-err (/ epoch-err num-patterns))
;	(if (or (> epoch-err prev-err)
;		(< (abs (- epoch-err prev-err)) (param params :thr))) 
;	    (progn (decf (param params :recompute))
;		   (when (> (param params :epsilon) (param params :eps-lower))
;		     (setf (param params :epsilon) (* (param params :epsilon) (param params :eps-dec)))))
;	    (progn (setf (param params :recompute) recompute-limit)
;		   (when (< (param params :epsilon) (param params :eps-upper))
;		     (setf (param params :epsilon) (* (param params :epsilon) (param params :eps-inc))))))
;	(when (minusp (param params :recompute))
;	  (return))
	(setf prev-err epoch-err
	      epoch-err 0)
	(info "err: ~A~%" prev-err)
	))
    weights))
