(in-package :annil)

(declaim (inline quickprop-update))

(defun quickprop-update (d s ps eps mu shrink-factor rate)
  "Quickprop update rule, choose linear or quadratic estimate out of slope size"
  (declare (type single-float d s ps eps mu shrink-factor)
	   (optimize speed (safety 0)))
  (let ((step 0.0))
    (cond ((minusp d)
	   (when (plusp s)
	     (%decf step (%* eps s))) 
	   (if (>= s (%* shrink-factor ps))
	       (%incf step (%* mu d))
	       (progn (%incf step (%* d (%/ s (%- ps s))))
		      (when rate (%decf step (%* rate s (heaviside (%* s ps))))))))
	  ((plusp d)
	   (when (minusp s)
	     (%decf step (%* eps s)))
	   (if (<= s (%* shrink-factor ps))
	       (%incf step (%* mu d))
	       (progn (%incf step (%* d (%/ s (%- ps s))))
		      (when rate (%decf step (%* rate s (heaviside (%* s ps))))))))
	  (t (%decf step (%* eps s))))
    step))

(defun quickprop (weights slopes-fn err-fn train-patterns test-patterns init-params)
  (declare (inline slopes-fn err-fn))
  (flet ((w-like () (make-matrix-like weights)))
    (let ((large-val (float most-positive-fixnum)))
      (let ((prev-slopes (w-like))
	    (delta-weights (w-like))
	    (best-weights (w-like))
	    
	    (npats (num-patterns train-patterns))
	    (test-npats (num-patterns test-patterns))
	    (err large-val) (err-1 0.0)
	    (test-err large-val) (test-err-1 0.0)
	    (best-crit large-val)
	    (epochs-passed 0) (recompute-flag nil)

	    (params (copy-tree init-params))
	    (verbosity (or (param init-params :verbosity) 0))
	    (recompute-limit (param init-params :recompute))
	    (thr (or (param init-params :thr) 0.0))
	    (rrate (param init-params :rrate))
	    (eps (/ (param init-params :eps) (num-patterns train-patterns)))
	    (mu (param init-params :mu))
	    (shr (/ (param init-params :mu) (1+ (param init-params :mu))))
	    (epochs-handicap (or (param init-params :epochs-handicap) 0))
	    (test-set-mix-ratio (param init-params :test-set-mix-ratio)))
	;; main loop
	(symbol-macrolet
	    ((crit (if test-patterns test-err err))
	     (crit-1 (if test-patterns test-err-1 err-1)))
	  (flet ((test-err-fn (w)
		   (if (and test-patterns test-set-mix-ratio)
		       (/ (+ (* err npats)
			     (* test-set-mix-ratio (funcall err-fn w)))
			  (+ npats (* test-set-mix-ratio test-npats)))
		       (/ (funcall err-fn w) test-npats))))
	    (dotimes (i (param params :epochs))
	      (incf epochs-passed)
	      (let ((slopes (w-like)))
;;; ==============================================================
		;; optimization part
		(multiple-value-bind (s e)
		    (funcall slopes-fn weights slopes)
		  (declare (ignore s))
		  (setf err-1 err
			err (/ e npats)))
		(when (and (not test-patterns)
			   (< crit best-crit))
		  (setf best-crit crit)
		  (copy weights best-weights))
		(smap-three-matrices delta-weights slopes prev-slopes
				     #'(lambda (d s ps)
					 (quickprop-update d s ps eps mu shr rrate)))
		(m+ weights delta-weights)
		(setf prev-slopes slopes)
		(when test-patterns
		  (setf test-err-1 test-err
			test-err (test-err-fn weights))
		  (when (< crit best-crit)
		    (setf best-crit crit)
		    (copy weights best-weights)))
;;; ==============================================================
		;; information part
		(when (>= verbosity 3)
		  (if test-patterns
		      (info "Current result: ~,5F, over test set: ~,5F~%" err test-err)
		      (info "Current result: ~,5F~%" err)))
		(when recompute-limit
		  (when (>= epochs-passed epochs-handicap)
		    (when (<= crit-1 crit) (setf recompute-flag t)))
		  (when recompute-flag
		    (if (<= crit-1 (* crit (1+ thr)))
			(decf (param params :recompute))
			(when (< (param params :recompute) recompute-limit)
			  (incf (param params :recompute) 1/2))))
		  (when (minusp (param params :recompute))
		    (when (>= verbosity 2) (info "Stagnant at ~A epoch~%" i))
		    (return)))))))
	(when (>= verbosity 1) (info "Final result: ~A~%" best-crit))
	(values best-weights best-crit epochs-passed)))))
