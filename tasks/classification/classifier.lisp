(in-package :annil)

(export '(classifier classify make-slp-classifier make-cascade-classifier))

(defclass classifier ()
  ((min-out :initarg :min-out :accessor classifier-min-out)
   (max-out :initarg :max-out :accessor classifier-max-out)
   (err-lim :initarg :err-lim :accessor classifier-err-lim)
   (network :initarg :network :accessor classifier-network)
   (preproc :initarg :preproc :accessor classifier-preproc)))

(defmethod eval-network ((network classifier) input)
  (eval-network (classifier-network network) (encode (classifier-preproc network) (copy input))))

(defun %classify-patterns (classifier patterns)
  (let (correct incorrect
	(err-lim (classifier-err-lim classifier))
	(nouts (patterns-output-dim patterns)))
    (do-patterns-safe (patterns p)
      (let ((out (eval-network classifier (first p)))
	    (res (make-array nouts))
	    (count 0))
	(dotimes (j nouts)
	  (when (< (abs (- (aref out j) (aref (second p) j)))
		   err-lim)
	    (setf (svref res j) T)
	    (incf count)))
	(if (= count nouts)
	    (push (list out (second p)) correct)
	    (push (list out (second p) res) incorrect))))
    (list correct incorrect)))

(defun %classify-pattern (classifier pattern)
  (let ((out (eval-network classifier (first pattern)))
	(res (make-array (dim0 (second pattern))))
	(min-out (classifier-min-out classifier))
	(max-out (classifier-max-out classifier))
	(err-lim (classifier-err-lim classifier))
	(count 0))
    (dotimes (j (dim0 res))
      (let ((d (abs (- (aref out j) (aref (second pattern) j)))))
	(when (< (min (abs (- d (aref min-out j)))
		      (abs (- d (aref max-out j))))
		 err-lim)
	  (setf (svref res j) T)
	  (incf count))))
    (values (= count (dim0 res))
	    out res)))

(defun classify (classifier patterns)
  (cond ((single-input-p patterns) (eval-network classifier patterns))
	((single-pattern-p patterns) (%classify-pattern classifier patterns))
	(t (%classify-patterns classifier patterns))))

(defun patterns-outputs-ranges (patterns)
  (let ((min (make-matrix (patterns-output-dim patterns)))
	(max (make-matrix (patterns-output-dim patterns))))
    (do-patterns-safe (patterns p)
      (let ((o (second p)))
	(map-into min #'(lambda (x y) (if (< x y) x y)) o min)
	(map-into max #'(lambda (x y) (if (> x y) x y)) o min)))
    (list min max)))

(defun make-slp-classifier (train-patterns test-patterns params &optional preproc)
  (let* ((enc-train-pats (encode preproc (copy-patterns train-patterns)))
	 (out-ranges (patterns-outputs-ranges train-patterns)))
    (make-instance 'classifier
		   :network (train-slp-network (make-slp-network (patterns-input-dim enc-train-pats)
								 (patterns-output-dim enc-train-pats)
								 (param params :act-fn))
					       enc-train-pats (when test-patterns (encode preproc (copy test-patterns))) params)
		   :preproc preproc
		   :err-lim (param params :misclassify-limit)
		   :min-out (first out-ranges)
		   :max-out (second out-ranges))))

(defun make-cascade-classifier (patterns test-part params cc-params &optional preproc display-fn)
  (let* ((enc-pats (encode preproc (copy-patterns patterns)))
	 (out-ranges (patterns-outputs-ranges enc-pats)))
    (make-instance 'classifier
		   :network (train-cascade-network (make-cascade-network (patterns-input-dim enc-pats)
									 (patterns-output-dim enc-pats)
									 (param params :act-fn) nil)
						   enc-pats test-part (param cc-params :hidden-num) params cc-params display-fn)
		   :preproc preproc
		   :err-lim (param params :misclassify-limit)
		   :min-out (first out-ranges)
		   :max-out (second out-ranges))))

(defun make-rcascade-classifier (patterns test-part params cc-params &optional preproc display-fn)
  (let* ((enc-pats (encode preproc (copy-patterns patterns)))
	 (out-ranges (patterns-outputs-ranges enc-pats)))
    (make-instance 'classifier
		   :network (train-recurrent-cascade-network (make-recurrent-cascade-network (patterns-input-dim enc-pats)
									 (patterns-output-dim enc-pats)
									 (param params :act-fn) nil)
						   enc-pats test-part (param cc-params :hidden-num) params cc-params display-fn)
		   :preproc preproc
		   :err-lim (param params :misclassify-limit)
		   :min-out (first out-ranges)
		   :max-out (second out-ranges))))
