(in-package :annil)

(export '(make-tseries-patterns))

(defun shift-ts-pattern (pattern new infs)
  (list (append-sf (second pattern)
		   (subseq (first pattern) 0 (- (length (first pattern)) (length infs) 1))
		   infs)
	  new))

(defun %make-tseries-patterns (tseries window)
  (let* ((vals (ts-values tseries))
	 (infs (ts-influences tseries))
	 (n (length vals))
	 (pats (make-array (- n window))))
    (setf (svref pats 0)
	  (list (append-sf (nreverse (subseq vals 0 window))
			   (svref infs (1- window)))
		(m1 (aref vals window))))
    (dotimes (i (- n window 1))
      (setf (svref pats (1+ i))
	    (shift-ts-pattern (svref pats i)
			      (m1 (aref vals (+ window i 1)))
			      (svref infs (+ window i 1)))))
    pats))

(defun make-tseries-patterns (tseries window)
  (ts-dispatch tseries
	       (%make-tseries-patterns tseries window)
	       (apply #'concatenate 'simple-vector
		      (mapcar #'(lambda (ts) (%make-tseries-patterns ts window))
			      (dts-parts tseries)))))

(defun log-ts-input (inp window log)
  (if log
      (let ((%inp (copy inp)))
	(dotimes (i window)
	  (setf (aref %inp i)
		(log (aref %inp i))))
	%inp)
      (copy inp)))

(defun diff-log-ts-pattern (inp prev-pat window log)
  (let ((%inp (log-ts-input inp window log))
	(prev-inp (log-ts-input (first prev-pat) window log)))
    (dotimes (i window)
      (decf (aref %inp i)
	    (aref prev-inp i)))
    (list %inp (m1 (let ((e (e1 (second prev-pat))))
		     (if log (log e) e))))))

(defun ts-encode-inp (inp prev-pat window bounds log)
  (let* ((pat (diff-log-ts-pattern inp prev-pat window log))
	 (%inp (first pat))
	 (val-bounds (svref bounds 0)))
    (dotimes (i window)
      (setf (aref %inp i)
	    (bound-scale-output-val (aref %inp i) val-bounds)))
    (dotimes (i (- (length %inp) window))
      (setf (aref %inp (+ i window))
	    (bound-scale-output-val (aref %inp (+ i window)) (svref bounds (1+ i)))))
    pat))
