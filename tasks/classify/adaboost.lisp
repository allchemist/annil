(in-package :annil)

(export '(adaboost-classifier make-adaboost-classifier boost-preproc boost-classifiers))

(defun adaboost-classifier-quality (classifier patterns)
  (let ((err 0.0))
    (do-patterns-safe (patterns p)
      (unless (nth-value 1 (classify classifier p))
	(incf err
	      (elt p 2) ; orig
	      ;(- 1.0 (tanh (elt p 2)))
	      )))
    err))

(defun make-adaboost-classifier (patterns train-single-fn params &optional preproc)
  (let (cls
	(npats (num-patterns patterns))
	(pats (convert-patterns-to-svector patterns))
	(verbosity (param params :verbosity))
	(pos-rem-count-glob 0)
	(neg-rem-count-glob 0)
	(neg/pos 1.0))
    (when verbosity (info "Initiating AdaBoost classifier training~%"))
    (if preproc (setf pats (encode preproc pats)))
    (if (not (patterns-with-weights-p patterns))
	(progn (dotimes (i npats)
		 (let ((p (svref pats i)))
		   (setf (svref pats i) (list (first p) (second p) (float (/ npats))))))
	       (normalize-patterns-weights pats))
	(let ((w (coerce (sort (remove-duplicates (map '(simple-array single-float (*)) #'third pats)) #'>) 'list)))
	  (setf neg/pos (/ (first w) (car (last w))))))
    (flet ((standard-deviation (data mean)
	     (let ((var 0.0))
	       (dotimes (i (dim0 data))
		 (incf var (square (- (aref data i) mean))))
	       (sqrt (/ var (dim0 data))))))
      (dotimes (n (param params :max-num))
	(when verbosity (info "Training ~A'th weak classifier~%" (1+ n)))
	(let* ((c (funcall train-single-fn pats))
	       (q (adaboost-classifier-quality c pats))
	       (a (* 0.5 (log (/ (+ 1 q) (- 1 q))))
		 ))
	  (dotimes (i npats)
	    (let ((p (svref pats i)))
	      (setf (elt p 2)
		    (* (elt p 2)
		       (exp (- (* a
				  (aref (second p) 0)
				  (aref (eval-network c (first p)) 0))))
		       ;(log (1+ (exp (- (* 2.0 a
					   ;(aref (second p) 0)
					   ;(aref (eval-network c (first p)) 0))))))
		       ))))
	  (normalize-patterns-weights pats)
	  (push (list c a) cls)
	  (when (and (param params :remove-outliers)
		     (> n 2))
	    (let ((weights (map '(simple-array single-float (*)) #'third pats)))
	      (dotimes (i (length weights))
		(when (plusp (aref (second (svref pats i)) 0))
		  (setf (aref weights i) (/ (aref weights i) (expt neg/pos (/ (sqrt (+ n 1))))))))
	      (let* ((mean (mean weights))
		     (sd (standard-deviation weights mean))
		     (pos-rem-count 0)
		     (neg-rem-count 0))
		(dotimes (i (length weights))
		  (let* ((w (aref weights i))
			 (p (svref pats i))
			 (plusp (plusp (aref (second p) 0))))
		    (if plusp (setf w (/ w neg/pos)))
		    (when (> w (+ mean (* 8 sd)))
		      (setf (elt p 2) 0.0)
		      (if plusp
			  (incf pos-rem-count)
			  (incf neg-rem-count)))))
		(incf pos-rem-count-glob pos-rem-count)
		(incf neg-rem-count-glob neg-rem-count)
		(unless (zerop (+ neg-rem-count pos-rem-count))
		  (normalize-patterns-weights pats))
		(when verbosity (info "Removed ~A positive and ~A negative outliers~%"
				      pos-rem-count neg-rem-count))))))))
    (let ((abc (make-instance 'adaboost-classifier :classifiers (nreverse cls) :preproc preproc)))
      (when verbosity
	(multiple-value-bind (err neg-bits pos-bits)
	    (compute-network-err abc patterns 1.0)
	  (info "Boost clasifier quality: error-sum= ~A, error-bits= ~A / ~A~%" err neg-bits pos-bits))
	(when (param params :remove-outliers)
	  (info "Total removed ~A positive and ~A negative outliers~%" pos-rem-count-glob neg-rem-count-glob)))
      abc)))
