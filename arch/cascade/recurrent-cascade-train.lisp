(in-package :annil)

(export '(train-recurrent-cascade-network))

(defun rcascade-compute-hidden-slopes-c2 (cascade cand slopes patterns errors-cache)
;  (declare (optimize speed (safety 0)))
  (declare (optimize debug))
  (let ((nunits (cascade-nunits cascade))
	(noutputs (cascade-noutputs cascade))
	(cand-score 0.0)
	(act-fn (cascade-act-fn cascade))
	(weights-p (patterns-with-weights-p patterns))
	(npats (float (num-patterns patterns)))
	(prev-val 0.0)
	;(cur-slopes (copy slopes))
	(prev-slopes (make-matrix-like slopes)))
    (let* ((fb-pos (+ noutputs nunits))
	   (ws (%fvref cand fb-pos)))
      (do-patterns-safe (patterns p i)
	(let* ((values (first p))
	       (val (activation (inner-prod cand values) act-fn))
	       (err-sum 0.0)
	       (errs (%svref errors-cache i))
	       (pw (if weights-p (%* (pattern-weight p) npats) 1.0)))
	  (%incf val (%* prev-val ws))
	  ;; output slopes
	  (%dotimes (o noutputs)
	    (let* ((w (%fvref cand (+ o nunits)))
		   (dif (%* pw (%- (%* w val) (%fvref errs o)))))
	      (%incf cand-score (%square dif))
	      (%incf (%fvref slopes (+ o nunits)) (%* dif val))
	      (%incf err-sum (%* dif w))))
	  (let ((deriv (activation-deriv val act-fn)))
	    (%setf err-sum (%* err-sum deriv))
	    ;; input slopes
	    (%dotimes (i nunits)
	      (%incf (%fvref slopes i)
		     (%+ (%* err-sum (%fvref values i))
			 (%* deriv ws (%fvref prev-slopes i)))))
			 ;)))
	    (%incf (%fvref slopes fb-pos)
		   (%* deriv
		       (%+ (%* ws (%fvref prev-slopes fb-pos))
			   prev-val)))
	    )
	  ;(setf prev-val val)
	  ;(scopy cur-slopes prev-slopes)
	  ;(m+ slopes cur-slopes)
	  )))
    (values slopes cand-score)))

(defun rcascade-compute-hidden-errors-c2 (cascade cand patterns errors-cache)
  ;(declare (optimize speed (safety 0)))
  (declare (optimize debug))
  (let ((nunits (cascade-nunits cascade))
	(cand-score 0.0)
	(act-fn (cascade-act-fn cascade))
	(weights-p (patterns-with-weights-p patterns))
	(npats (float (num-patterns patterns)))
	(prev-val 0.0))
    (let* ();(fb-pos (+ (cascade-nunits cascade) (cascade-noutputs cascade)))
	   ;(ws (%fvref cand fb-pos)))
      (do-patterns-safe (patterns p i)
	(let ((val (activation (inner-prod cand (first p)) act-fn))
	      (errs (%svref errors-cache i))
	      (pw (if weights-p (%* (pattern-weight p) npats) 1.0)))
	  ;(%incf val (%* prev-val ws))
	  (%dotimes (o (cascade-noutputs cascade))
	    (%incf cand-score (%square
			       (%* pw
				   (%- (%* (%fvref cand (+ o nunits)) val)
				       (%fvref errs o))))))
	  (%setf prev-val val))))
    cand-score))

(defun rcascade-install-hidden-c2 (cascade cand &optional cand-conns)
  (declare (optimize debug))
  (rcascade-insert-node cascade cand-conns)
  (let* ((noutputs (cascade-noutputs cascade))
	 (ow (cascade-out-weights cascade))
	 (conns (cascade-out-conns cascade))
	 (node (- (length cand) noutputs 1))
	 (off 0))
    (copy (subseq cand 0 node)
	  (svref (cascade-weights cascade) node))
    (dotimes (o noutputs)
      (let ((c (1- (length (svref conns o)))))
	(setf (aref ow (+ off c o)) (- (aref cand (+ node o))))
	(incf off c))))
  (setf (aref (cascade-feedbacks cascade) (1- (cascade-nhidden cascade)))
	(aref cand (1- (length cand))))
  cascade)

(defun rcascade-train-hidden-c2 (cascade patterns ncands test-part params)
  (declare (optimize debug))
  (let ((method (or (param params :method) :quickprop))
	(cands (make-array ncands))
	(cand-scores (make-matrix ncands))
	(copy-params (copy-tree params))
	train test)
;    (when (eq method :quickprop)
;      (setf (param params :eps) (/ (param params :eps) (sqrt (num-patterns patterns)))))
    (if (or (null test-part) (zerop test-part))
	(setf train patterns)
	(multiple-value-setq (train test)
	  (cv-split-patterns patterns test-part t)))
    (let ((train-values-cache (make-array (num-patterns train)))
	  (train-errors-cache (make-array (num-patterns train)))
	  test-values-cache test-errors-cache)
      (m*c (cascade-values cascade) 0.0)
      (do-patterns-safe (train p i)
	(cascade-install-input cascade (first p))
	(rcascade-set-prev-values cascade)
	(rcascade-eval-node cascade (1- (cascade-nunits cascade)))
	(cascade-eval-output cascade)
	(setf (svref train-values-cache i)
	      (cons (copy (cascade-values cascade)) (cdr p)))
	(setf (svref train-errors-cache i)
	      (m- (copy (second p))
		  (cascade-outputs cascade))))
      (when test
	(setf test-values-cache (make-array (num-patterns test))
	      test-errors-cache (make-array (num-patterns test)))
	(m*c (cascade-values cascade) 0.0)
	(do-patterns-safe (test p i)
	  (cascade-install-input cascade (first p))
	  (rcascade-set-prev-values cascade)
	  (rcascade-eval-node cascade (1- (cascade-nunits cascade)))
	  (setf (svref test-values-cache i)
		(cons (copy (cascade-values cascade)) (cdr p)))
	  (setf (svref test-errors-cache i)
		  (m- (copy (second p))
		      (cascade-outputs cascade)))))
;;; ==============================================================
      (flet ((slopes-fn (w s)
	       (declare (type (simple-array single-float) w s)
			(optimize speed (safety 0)))
	       (rcascade-compute-hidden-slopes-c2 cascade w s train-values-cache train-errors-cache))
	     (err-fn (w)
	       (declare (type (simple-array single-float) w)
			(optimize speed (safety 0)))
	       (rcascade-compute-hidden-errors-c2 cascade w test-values-cache test-errors-cache)))
	(dotimes (i ncands)
	  (let ((cand (seed-weights (make-matrix (+ (cascade-nunits cascade) (cascade-noutputs cascade))))))
	    (setf cand (extend-vector cand))
	    (multiple-value-bind (w e)
		(optimize-with-restarts cand method #'slopes-fn #'err-fn train-values-cache test-values-cache copy-params)
	      (setf (svref cands i) w)
	      (setf (aref cand-scores i) e))))))
    (svref cands (imin cand-scores))))

(defun train-recurrent-cascade-network (cascade patterns test-part nodes params cc-params &optional display-fn)
  (declare (optimize debug))
  (let ((last-epoch 0) (npats (num-patterns patterns))
	(best-crit most-positive-fixnum)
	(neg-err-bits 0) (pos-err-bits 0)
	(max-neg-err-bits (or (param params :max-neg-err-bits) (param params :max-err-bits) 0))
	(max-pos-err-bits (or (param params :max-pos-err-bits) (param params :max-err-bits) 0))
	(classify-range (param params :misclassify-limit))
	(verbosity (or (param params :verbosity) 0)))
    (when classify-range
      (when (floatp max-pos-err-bits)
	(let ((num-pos-patterns 0))
	  (do-patterns-safe (patterns p)
	    (when (plusp (aref (second p) 0)) (incf num-pos-patterns)))
	  (setf max-pos-err-bits (round (* max-pos-err-bits num-pos-patterns)))
	  (setf max-neg-err-bits (round (* max-neg-err-bits (- (num-patterns patterns) num-pos-patterns)))))))
    (flet ((display () (when display-fn (funcall display-fn cascade))))
      (flet ((train-outputs ()
	       (multiple-value-bind (w c e)
		   (cascade-train-output cascade patterns (cascade-out-test-part-size test-part cascade npats) params)
		 (declare (ignore w))
		 (setf best-crit c)
		 (incf last-epoch e))
	       (display)
	       (when classify-range
		 (multiple-value-bind (sum neg-bits pos-bits)
		     (compute-network-err cascade patterns classify-range)
		   (declare (ignore sum))
		   (setf neg-err-bits neg-bits
			 pos-err-bits pos-bits))
		 (when (>= verbosity 2)
		   (info "Error bits count: ~A / ~A~%" neg-err-bits pos-err-bits))
		 (if (and (<= pos-err-bits max-pos-err-bits)
		          (<= neg-err-bits max-neg-err-bits))
		     ;(</= (+ pos-err-bits neg-err-bits) (+ max-pos-err-bits max-neg-err-bits))
		     (progn (when (>= verbosity 1) (info "No other nodes needed~%")) t)
		     nil))))
;;; ==============================================================
	(when (train-outputs) (return-from train-recurrent-cascade-network cascade))
	(dotimes (i nodes)
	  (when (>= verbosity 1) (info "Training ~A node~%" (1+ i)))
	  (multiple-value-bind (w c e)
	      (rcascade-train-hidden-c2 cascade patterns (param cc-params :candidates)
				       nil ;(cascade-cand-test-part-size test-part cascade npats)
				       cc-params)
	    (declare (ignore c e))
	    (rcascade-install-hidden-c2 cascade w))
	  (when (train-outputs) (return))
	  (when (>= verbosity 2) (info "Epochs passed: ~A~%" last-epoch))))))
  cascade)
