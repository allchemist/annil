(in-package :annil)

(declaim (inline cascade-compute-hidden-slopes-c2 cascade-compute-hidden-errors-c2))

(defun cascade-compute-hidden-slopes-c2 (cascade cand slopes patterns errors-cache)
  (declare (optimize speed (safety 0)))
  (let ((nunits (cascade-nunits cascade))
	(noutputs (cascade-noutputs cascade))
	(cand-score 0.0)
	(act-fn (cascade-act-fn cascade))
	(weights-p (patterns-with-weights-p patterns))
	(npats (float (num-patterns patterns))))
    (do-patterns-safe (patterns p i)
      (let* ((values (first p))
	     (val (activation (inner-prod cand values) act-fn))
	     (err-sum 0.0)
	     (errs (%svref errors-cache i))
	     (pw (if weights-p (%* (pattern-weight p) npats) 1.0)))
	;; output slopes
	(%dotimes (o noutputs)
	  (let* ((w (%fvref cand (+ o nunits)))
		 (dif (%* pw (%- (%* w val) (%fvref errs o)))))
	    (%incf cand-score (%square dif))
	    (%incf (%fvref slopes (+ o nunits)) (%* dif val))
	    (%incf err-sum (%* dif w))))
	(%setf err-sum (%* err-sum (activation-deriv val act-fn)))
	;; input slopes
	(%dotimes (i nunits)
	  (%incf (%fvref slopes i) (%* err-sum (%fvref values i))))))
    (values slopes cand-score)))

(defun cascade-compute-hidden-errors-c2 (cascade cand patterns errors-cache)
  (declare (optimize speed (safety 0)))
  (let ((nunits (cascade-nunits cascade))
	(cand-score 0.0)
	(act-fn (cascade-act-fn cascade))
	(weights-p (patterns-with-weights-p patterns))
	(npats (float (num-patterns patterns))))
    (do-patterns-safe (patterns p i)
      (let ((val (activation (inner-prod cand (first p)) act-fn))
	    (errs (%svref errors-cache i))
	    (pw (if weights-p (%* (pattern-weight p) npats) 1.0)))
	(%dotimes (o (cascade-noutputs cascade))
	  (%incf cand-score (%square
			     (%* pw
				 (%- (%* (%fvref cand (+ o nunits)) val)
				     (%fvref errs o))))))))
    cand-score))

(defun cascade-train-hidden-c2 (cascade patterns ncands test-part params)
  (let ((method (or (param params :method) :quickprop))
	(cands (make-array ncands))
	(cand-scores (make-matrix ncands))
	(copy-params (copy-tree params))
	train test)
;    (when (eq method :quickprop)
;      (setf (param params :eps) (/ (param params :eps) (sqrt (num-patterns patterns)))))
    (if (or (null test-part) (zerop test-part))
	(setf train patterns)
	(multiple-value-setq (train test)
	  (cv-split-patterns patterns test-part (param params :test-sequential))))
    (let ((train-values-cache (make-array (num-patterns train)))
	  (train-errors-cache (make-array (num-patterns train)))
	  test-values-cache test-errors-cache)
      (do-patterns-safe (train p i)
	(cascade-install-input cascade (first p))
	(cascade-eval-node cascade (1- (cascade-nunits cascade)))
	(cascade-eval-output cascade)
	(setf (svref train-values-cache i)
	      (cons (copy (cascade-values cascade)) (cdr p)))
	(setf (svref train-errors-cache i)
	      (m- (copy (second p))
		  (cascade-outputs cascade))))
      (when test
	(setf test-values-cache (make-array (num-patterns test))
	      test-errors-cache (make-array (num-patterns test)))
	(do-patterns-safe (test p i)
	  (cascade-install-input cascade (first p))
	  (cascade-eval-node cascade (1- (cascade-nunits cascade)))
	  (setf (svref test-values-cache i)
		(cons (copy (cascade-values cascade)) (cdr p)))
	  (setf (svref test-errors-cache i)
		  (m- (copy (second p))
		      (cascade-outputs cascade)))))
;;; ==============================================================
      (flet ((slopes-fn (w s)
	       (declare (type (simple-array single-float) w s)
			(optimize speed (safety 0)))
	       (cascade-compute-hidden-slopes-c2 cascade w s train-values-cache train-errors-cache))
	     (err-fn (w)
	       (declare (type (simple-array single-float) w)
			(optimize speed (safety 0)))
	       (cascade-compute-hidden-errors-c2 cascade w test-values-cache test-errors-cache)))
	(dotimes (i ncands)
	  (let ((cand (seed-weights (make-matrix (+ (cascade-nunits cascade) (cascade-noutputs cascade))))))
	    (multiple-value-bind (w e)
		(optimize-with-restarts cand method #'slopes-fn #'err-fn train-values-cache test-values-cache copy-params)
	      (setf (svref cands i) w)
	      (setf (aref cand-scores i) e))))))
    (svref cands (imin cand-scores))))

(defun cascade-install-hidden-c2 (cascade cand &optional cand-conns)
  (cascade-insert-node cascade cand-conns)
  (let* ((noutputs (cascade-noutputs cascade))
	 (ow (cascade-out-weights cascade))
	 (conns (cascade-out-conns cascade))
	 (node (- (length cand) noutputs))
	 (off 0))
    (copy (subseq cand 0 node)
	  (svref (cascade-weights cascade) node))
    (dotimes (o noutputs)
      (let ((c (1- (length (svref conns o)))))
	(setf (aref ow (+ off c o)) (- (aref cand (+ node o))))
	(incf off c)))
    cascade))
