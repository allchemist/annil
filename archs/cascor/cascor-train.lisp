(in-package :annil)

(defun cascor-train (cascor train-patterns test-patterns nodes params cc-params)
  (let ((last-epoch 0))
    (incf last-epoch (nth-value 2 (cascor-train-output cascor train-patterns test-patterns params)))
    (dotimes (i nodes)
      (info "~%")
      (info "Training ~A node~%" (1+ (cascor-insert-node cascor)))
      (cascor-train-hidden cascor train-patterns cc-params)
      (cascor-connect-node cascor)
      (info "Connecting to outputs~%")
      (incf last-epoch (nth-value 2 (cascor-train-output cascor train-patterns test-patterns params)))
      (info "Epochs passed: ~A~%" last-epoch)))
  cascor)

(defun cascor-train-output (cascor train-patterns test-patterns params)
  ;; perform sse optimization
  (assert (cascor-without-unconnected-node-p cascor) nil "There is an unconnected node")
  (optimize-sse (cascor-output-weights cascor)
		(cascor-full-patterns cascor train-patterns)
		(cascor-full-patterns cascor test-patterns)
		(cascor-act-fn cascor) params))

(defun cascor-train-hidden (cascor patterns params)
  ;; check for unconnected node to be trained
  (assert (not (cascor-without-unconnected-node-p cascor)) nil "No unconnected nodes")
  (let ((full-patterns (cascor-full-patterns cascor patterns))
	(node (1- (cascor-hidden-num cascor))))
    (setf (cascor-node-weights cascor node)
	  (cascor-train-hidden-unit (cascor-output-weights cascor) full-patterns
				    (cascor-act-fn cascor) (copy-tree params)))))

(defun cascor-corr (V E &optional sign-dest)
  (let ((V-c (m-c (copy V) (mean V)))
	(corr 0))
    (dotimes (o (length E))
      (let ((corr-val (inner-prod V-c (elt E o))))
	(when sign-dest
	  (setf (aref sign-dest o) (signum corr-val)))
	(incf corr (abs corr-val))))
    corr))

(defun cascor-train-hidden-unit (output-weights full-patterns act-fn params)
  (let ((-N (num-patterns full-patterns))
	(-I (patterns-input-dim full-patterns))
	(-O (patterns-output-dim full-patterns))
	(act-fn-deriv (deriv-fn-name act-fn))
	(method (or (param params :method) :quickprop))
	(verbosity (param params :verbosity)))
    (let ((V (make-matrix -N))
	  (E (loop for i from 0 below -O collect (make-matrix -N)))
	  (sse 0.0))
      ;; caching output errors
      (let ((tmp-out (make-matrix -O)))
	(dotimes (j -N)
	  (let ((p (get-pattern-safe full-patterns j)))
	    (map-two-matrices (gemv output-weights (first p) :dest tmp-out)
			      (second p)
			      #'(lambda (o d)
				  (let ((val (funcall act-fn o)))
				    (* (- val d)
				       (funcall act-fn-deriv val))))))
	  (dotimes (i -O)
	    (setf (aref (elt E i) j) (aref tmp-out i))))
	(dolist (o E)
	  (dotimes (j -N)
	    (incf sse (square (aref o j))))
	  (m-c o (mean o))))
      ;; slopes calculating
      (let ((sign-dest (make-matrix -O)))
	(flet ((cc-compute-slopes (w s)
		 (dotimes (j -N)
		   (let ((p (get-pattern-safe full-patterns j)))
		     (setf (aref V j) (funcall act-fn (inner-prod (first p) w)))))
		 (let ((corr (cascor-corr V E sign-dest)))
		   (dotimes (j -N)
		     (let ((p (get-pattern-safe full-patterns j))
			   (lg 0.0))
		       (dotimes (i -O)
			 (decf lg (* (aref sign-dest i)
				     (aref (elt E i) j)
				     (funcall act-fn-deriv (aref V j)))))
		       (axpy (first p) s (/ lg sse))))
		   (values s (* corr -N)))))
	  (when (>= verbosity 1) (info "Training candidates "))
	  (let (candidates)
	    (decf (param params :verbosity) 2)
	    (dotimes (i (param params :candidates))
	      (when (= verbosity 2) (princ "."))
	      (when (>= verbosity 3) (terpri) (info "New candidate~%"))
	      (multiple-value-bind (cand-weights cand-corr) 
		  (funcall (intern (string method) :annil)
			   (m*c (make-random-matrix -I) 0.25)
			   #'cc-compute-slopes nil full-patterns nil params)
		(push (cons cand-corr cand-weights) candidates)))
	    (let ((best (first (sort candidates #'> :key #'car))))
	      (when (= verbosity 2) (terpri))
	      (when (>= verbosity 1)
		(info "Best corr: ~A~%" (car best)))
	      (cdr best))))))))
