(in-package :annil)

(defun obd-min-salience (weights hessian-diag)
  (let* ((S (m* (m* hessian-diag weights) weights))
	 (idx (imin S)))
    (values idx (aref S idx))))
#|
(defun obd (hess-fn weights-fn delete-fn patterns params)
  (declare (optimize debug))
  (let ((pruned-num 0)
	(prune-limit (param params :prune-limit))
	(prune-thr (param params :prune-thr)))
    (let ((w (funcall weights-fn)))
      (multiple-value-bind (Hd err)
	  (funcall hess-fn)
	(let ((S (m* (m* Hd w) w)))
	  (dotimes (iter (or prune-limit (dim0 (funcall weights-fn))))
	    (let* ((idx (imin S))
		   (max (mmax S))
		   (val (aref S idx)))
	      (if (< val (* err prune-thr))
		  (progn 
		    (when (>= (param params :verbosity) 4) (info "Conection pruned~%"))
		    (incf pruned-num)
		    (setf (aref S idx) max)
		    (funcall delete-fn idx))
		  (return)))))))
    pruned-num))
|#

(defun obd (hess-fn weights-fn delete-fn patterns params)
  (let ((pruned-num 0)
	(prune-limit (param params :prune-limit))
	(prune-thr (param params :prune-thr)))
    (dotimes (iter (case prune-limit
		     (:auto (round (* 0.66 (dim0 (funcall weights-fn)))))
		     (nil (dim0 (funcall weights-fn)))
		     (t prune-limit)))
      (let ((w (funcall weights-fn)))
	(multiple-value-bind (Hd err)
	    (funcall hess-fn)
	  (let ((S (m* (m* Hd w) w)))
	    (let* ((idx (imin S))
		   (val (aref S idx)))
	      (if (< val (* err prune-thr))
		  (progn 
		    (when (>= (param params :verbosity) 4) (info "Conection pruned~%"))
		    (incf pruned-num)
		    (funcall delete-fn idx))
		  (return)))))))
    pruned-num))
