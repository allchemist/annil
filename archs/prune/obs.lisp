(in-package :annil)

(defun obs-inv-hessian (slopes-fn weights patterns)
  (let* ((len (dim0 weights))
	 (Hinv (setf (diag (make-matrix `(,len ,len)))
		     (make-matrix len :initial-element 100.0)))
	 (err 0.0))
    (dotimes (i (num-patterns patterns))
      (multiple-value-bind (s e)
	  (funcall slopes-fn weights i)
	(let ((tmp (gemm Hinv s)))
	  (incf err e)
	  (m- Hinv
	      (m/c (gemm (gemm tmp s :transb :trans) Hinv)
		   (1+ (aref (gemm s tmp :transa :trans) 0 0)))))))
    (values Hinv (/ err (num-patterns patterns)))))

(defun obs-min-salience (weights inv-hessian)
  (let ((S (make-matrix-like weights)))
    (dotimes (i (dim0 S))
      (setf (aref S i)
	    (/ (square (aref weights i))
	       2 (aref inv-hessian i i))))
    (let ((idx (imin S)))
      (values idx (aref S idx)))))  

(defun obs-mod-weights (weights inv-hessian idx)
  (axpy (col inv-hessian idx) weights
	(- (/ (aref weights idx)
	      (aref inv-hessian idx idx)))))

(defun obs (slopes-fn weights-fn delete-fn patterns params)
  (let ((pruned-num 0)
	(prune-limit (param params :prune-limit))
	(prune-thr (param params :prune-thr)))
    (dotimes (iter (or prune-limit (dim0 (funcall weights-fn))))
      (let ((w (funcall weights-fn)))
	(multiple-value-bind (Hinv err)
	    (case (param params :hess-method)
	      (:direct (funcall slopes-fn))
	      ((:recursive nil) (obs-inv-hessian slopes-fn w patterns)))
	  (multiple-value-bind (idx val)
	      (obs-min-salience w Hinv)
	    (if (< val (* err prune-thr))
		(progn 
		  (when (>= (param params :verbosity) 4) (info "Conection pruned~%"))
		  (obs-mod-weights w Hinv idx)
		  (incf pruned-num)
		  (funcall delete-fn idx))
		(return))))))
    pruned-num))
