(in-package :annil)

(export 'nipals)

(defun nipals (X pc &key (max-iter 10000) (thr 1.e-7) verbosity)
  (when (not (typep verbosity 'fixnum)) (setf verbosity 0))
  (if pc
      (assert (<= pc (dim1 X)) nil "Trying to extract too much principal components")
      (setf pc (dim1 X)))
  (when (>= verbosity 1)
    (info "Performing NIPALS extraction of ~A principal components.~%" pc))
  (let ((-T (make-matrix `(,(dim0 X) ,pc)))
	(-P (make-matrix `(,(dim1 X) ,pc))))
    (dotimes (i pc)
      (let ((%t (col X i))
	    (%p (make-matrix (dim1 X)))
	    (t-old 0.0)
	    (t-new 1000.0))
	(dotimes (i max-iter)
	  (setf t-old t-new
		t-new (inner-prod %t %t))
	  (let ((percent-error (abs (- 1.0 (/ t-old t-new)))))
	    (when (>= verbosity 3)
	      (info "Current iteration percept error is ~A~%" percent-error))
	    (when (< percent-error thr)
	      (return)))
	  (m/c (gemv X %t :transa :trans :dest %p) t-new)
	  (normalize %p)
	  (m/c (gemv X %p :dest %t) (inner-prod %p %p)))
	(ger %t %p :dest X :alpha -1.0) ;; ?
	(setf (col -T i) %t)
	(setf (col -P i) %p)
	(when (>= verbosity 2)
	  (info "Errors norm after component extracting is ~A~%" (e-norm X)))))
    (values -T -P X)))
