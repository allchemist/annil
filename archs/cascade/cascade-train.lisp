(in-package :annil)

(export '(cascade-compute-out-slopes cascade-compute-out-errors cascade-train-output cascade-train))
(declaim (inline cascade-compute-out-slopes cascade-compute-out-errors))

(defun cascade-compute-out-slopes (cascade slopes patterns params)
  (declare (optimize speed (safety 0)))
  (let ((lgrad (make-matrix (cascade-noutputs cascade)))
	(err 0.0)
	(deriv-offset (param params :deriv-offset))
	(act-fn (when (cascade-if-nonlinear-outputs cascade) (cascade-act-fn cascade)))
	(deriv-fn (deriv-fn-name (cascade-act-fn cascade))))
    (%dotimes (i (num-patterns patterns))
      (let ((p (get-pattern-safe patterns i)))
	;; calculate local grad and error
	(scopy (cascade-eval-output cascade (first p)) lgrad)
	;(m- lgrad (second p))
	(saxpy (second p) lgrad -1.0)
	(%incf err (%square (e-norm lgrad)))
	;;;; count error bits
	;; (when classify-range
	;;   (%dotimes (i (dim0 lgrad))
	;;     (when (> (abs (%fvref lgrad i)) classify-range)
	;;       (incf err-bits))))
	;; calculate slopes
	(when act-fn
	  (smap-two-matrices lgrad (cascade-outputs cascade)
			    #'(lambda (x y)
				(declare (type single-float x y)
					 (optimize speed (safety 0)))
				(the single-float
				  (%* x (if deriv-offset
					    (%+ (funcall deriv-fn y) deriv-offset)
					    (funcall deriv-fn y)))))))
	;; modify slopes
;	(m+ slopes (ger lgrad (first p))))) ; !!! FIX IT with sger
	(sger slopes lgrad (first p) 1.0 :noconj)))
    (values slopes err)))

(defun cascade-compute-out-errors (cascade patterns params)
  (declare (optimize speed (safety 0)))
  (let ((err 0.0))
    (%dotimes (i (num-patterns patterns))
      (let* ((p (get-pattern-safe patterns i))
	     (out (cascade-eval-output cascade (first p))))
	(m- out (second p))
	(%incf err (%square (e-norm out)))
	;;;; count error bits
	;; (when classify-range
	;;   (%dotimes (i (dim0 out))
	;;     (when (< (%fvref out i) classify-range)
	;;       (incf err-bits))))))
	))
    err))

(defun cascade-train-output (cascade patterns test-part params)
  (let ((cache (make-array (num-patterns patterns)))
	(method (or (param params :method) :quickprop))
	train test)
    (dotimes (i (num-patterns patterns))
      (let ((p (get-pattern-safe patterns i)))
	(cascade-install-input cascade (first p))
	(cascade-eval-node cascade (1- (cascade-nunits cascade)))
	(setf (svref cache i)
	      (list (copy (cascade-values cascade))
		    (second p)))))
    (if (or (null test-part) (zerop test-part))
	(setf train cache)
	(multiple-value-setq (train test)
	  (cv-split-patterns cache test-part)))
    (flet ((slopes-fn (w s)
	     (declare (ignore w)
		      (type (simple-array single-float) s))
	     (cascade-compute-out-slopes cascade s train params))
	   (err-fn (w)
	     (declare (ignore w))
	     (cascade-compute-out-errors cascade (or test train) params)))
      (optimize-with-restarts (cascade-out-weights cascade)
			      method #'slopes-fn #'err-fn train test params))))

(defun cascade-train (cascade patterns test-part nodes params cc-params &optional display-fn)
  (let ((last-epoch 0) (best-crit most-positive-fixnum)
	(err-bits 0) (max-err-bits (or (param params :max-err-bits) 0))
	(classify-range (param params :classify-range))
	(verbosity (or (param params :verbosity) 0)))
    (when (floatp max-err-bits)
      (setf max-err-bits (round (* max-err-bits (num-patterns patterns)))))
    (flet ((display () (when display-fn (funcall display-fn cascade))))
      (flet ((train-outputs ()
	       (multiple-value-bind (w c e)
		   (cascade-train-output cascade patterns
					 (cond ((eq test-part :auto)
						(/ (sqrt (* 1.5 (cascade-num-weights cascade)))))
					       ((numberp test-part) test-part))
					 params)
		 (declare (ignore w))
		 (setf best-crit c)
		 (incf last-epoch e))
	       (display)
	       (when classify-range
		 (multiple-value-bind (sum bits)
		     (compute-network-err cascade patterns classify-range)
		   (declare (ignore sum))
		   (setf err-bits bits))
		 (when (>= verbosity 2) (info "Error bits count: ~A~%" err-bits))
		 (if (<= err-bits max-err-bits)
		     (progn (when (>= verbosity 1) (info "No other nodes needed~%")) t)
		     nil))))
;;; ==============================================================
	(when (train-outputs) (return-from cascade-train cascade))
	(dotimes (i nodes)
	  (when (>= verbosity 1) (info "Training ~A node~%" (1+ i)))
	  (multiple-value-bind (w c e)
	      (cascade-train-hidden-c2 cascade patterns (param cc-params :candidates)
				       (cond ((eq test-part :auto)
					      (/ (sqrt (* 2 (cascade-num-weights cascade)))))
					     ((numberp test-part) test-part))
				       cc-params)
	    (declare (ignore c e))
	    (cascade-install-hidden-c2 cascade w))
	  (when (train-outputs) (return))
	  (when (>= verbosity 2) (info "Epochs passed: ~A~%" last-epoch))))))
  cascade)
