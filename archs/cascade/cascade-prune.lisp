(in-package :annil)

;; prune outputs

(defun cascade-compute-out-slopes-for-pattern (cascade i values-cache params)
  (let ((lgrad (make-matrix (cascade-noutputs cascade)))
	(deriv-offset (param params :deriv-offset))
	(act-fn (when (cascade-if-nonlinear-outputs cascade) (cascade-act-fn cascade)))
	(deriv-fn (deriv-fn-name (cascade-act-fn cascade)))
	(pattern (get-pattern-safe values-cache i)))
    ;; calculate local grad and error
    (cascade-eval-output cascade (first pattern))
    (copy (cascade-outputs cascade) lgrad)
    (m- lgrad (second pattern))
    ;; calculate slopes
    (when act-fn
      (map-two-matrices lgrad (cascade-outputs cascade)
			 #'(lambda (x y)
			     (* x (if deriv-offset
				      (+ (funcall deriv-fn y) deriv-offset)
				      (funcall deriv-fn y))))))
    (values (cascade-out-slopes cascade lgrad :values (first pattern))
	    (square (e-norm lgrad)))))

(defun cascade-compute-out-inv-hessian (cascade values-cache params)
  (let ((J (make-matrix (list (num-patterns values-cache) (length (cascade-out-weights cascade)))))
	(err 0.0)
	(hess-diag (make-matrix (length (cascade-out-weights cascade)))))
    (dotimes (i (num-patterns values-cache))
      (multiple-value-bind (s e)
	  (cascade-compute-out-slopes-for-pattern cascade i values-cache params)
	(setf (row J i) (sb-ext:array-storage-vector s))
	(incf err e)))
    (values (mth::lu-inverse (gemm J J :transa :trans :alpha 2.0))
	    err)))
#|
(defun cascade-compute-out-hess-diag (cascade values-cache params)
  (let ((hess-diag (make-matrix (length (cascade-out-weights cascade))))
	(err .0))
    (dotimes (i (num-patterns values-cache))
      (multiple-value-bind (s e)
	  (cascade-compute-out-slopes-for-pattern cascade i values-cache params)
	(setf (aref hess-diag i) (* (inner-prod s s) 2))
	(incf err e)))
    (values hess-diag err)))|#

(defun cascade-compute-out-hess-diag (cascade values-cache params)
  (let ((J (make-matrix (list (num-patterns values-cache) (length (cascade-out-weights cascade)))))
	(err 0.0)
	(hess-diag (make-matrix (length (cascade-out-weights cascade)))))
    (dotimes (i (num-patterns values-cache))
      (multiple-value-bind (s e)
	  (cascade-compute-out-slopes-for-pattern cascade i values-cache params)
	(setf (row J i) (sb-ext:array-storage-vector s))
	(incf err e)))
    (dotimes (i (length hess-diag))
      (setf (aref hess-diag i) (* (square (e-norm (col J i))) 2.0)))
    (values hess-diag err)))

(defun cascade-prune-outputs (cascade patterns params)
  (let ((values-cache (make-array (num-patterns patterns))))
    (dotimes (i (num-patterns patterns))
      (let ((p (get-pattern-safe patterns i)))
	(cascade-install-input cascade (first p))
	(cascade-eval-node cascade (1- (cascade-nunits cascade)))
	(cascade-eval-output cascade)
	(setf (svref values-cache i)
	      (list (copy (cascade-values cascade))
		    (second p)))))
    (flet ((slopes-fn (w i)
	     (declare (ignore w))
	     (cascade-compute-out-slopes-for-pattern cascade i values-cache params))
	   (weights-fn () (cascade-out-weights cascade))
	   (delete-fn (idx)
	     (let ((out-conns (cascade-out-conns cascade))
		   (off 0))
	       (dotimes (c (length out-conns))
		 (let ((conns (svref out-conns c)))
		   (if (>= (+ (length conns) off) idx)
		       (return (cascade-prune-out-connection cascade (- (aref conns idx) off) c))
		       (incf off (length conns))))))))
      (if (eq (param params :hess-method) :diag)
	  (obd #'(lambda () (cascade-compute-out-hess-diag cascade values-cache params))
	       #'weights-fn #'delete-fn values-cache params)
	  (obs (if (eq (param params :hess-method) :direct)
		   #'(lambda () (cascade-compute-out-inv-hessian cascade values-cache params))
		   #'slopes-fn)
	       #'weights-fn #'delete-fn values-cache params)))))

;; prune node

(defun cascade-compute-cand-slopes-c2-for-pattern (cascade cand out-cand conns pattern-idx values-cache errors-cache params)
  (let ((noutputs (cascade-noutputs cascade))
	(cand-score 0.0)
	(act-fn (cascade-act-fn cascade))
	(deriv-fn (deriv-fn-name (cascade-act-fn cascade)))
	(values (first (get-pattern-safe values-cache pattern-idx)))
	(val 0.0)
	(err-sum 0.0)
	(errs (%svref errors-cache pattern-idx))
	(slopes (make-matrix `(,(dim0 conns) 1))))
    (dotimes (i (dim0 conns))
      (incf val (* (aref cand i) (aref values (aref conns i)))))
    (setf val (funcall act-fn val))
    ;; output slopes
    (%dotimes (o noutputs)
      (let* ((w (%fvref out-cand o))
	     (dif (%- (%* w val) (%fvref errs o))))
	(%incf cand-score (%square dif))
	;(%incf (%fvref slopes (+ o nunits)) (%* dif val))
	(%incf err-sum (%* dif w))))
    (%setf err-sum (%* err-sum (funcall deriv-fn val)))
    ;; input slopes
    (%dotimes (i (dim0 conns))
      (%incf (row-major-aref slopes i) (%* err-sum (%fvref values (%ivref conns i)))))
    (values slopes cand-score)))

(defun cascade-compute-cand-hess-diag (cascade cand out-cand conns values-cache errors-cache params)
  (let ((J (make-matrix (list (num-patterns values-cache) (length cand))))
	(err 0.0)
	(hess-diag (make-matrix (length cand))))
    (dotimes (i (num-patterns values-cache))
      (multiple-value-bind (s e)
	  (cascade-compute-cand-slopes-c2-for-pattern cascade cand out-cand conns i values-cache errors-cache params)
	(setf (row J i) s)
	(incf err e)))
    (dotimes (i (length hess-diag))
      (setf (aref hess-diag i) (* (square (e-norm (col J i))) 2.0)))
    (values hess-diag err)))

(defun cascade-prune-cand (cascade full-cand patterns params)
  (declare (optimize debug))
  (let ((values-cache (make-array (num-patterns patterns)))
	(errors-cache (make-array (num-patterns patterns)))
	(conns (iota (cascade-nunits cascade)))
	(cand (subseq full-cand 0 (cascade-nunits cascade)))
	(out-cand (subseq full-cand (cascade-nunits cascade))))
    (dotimes (i (num-patterns patterns))
      (let ((p (get-pattern-safe patterns i)))
	(cascade-install-input cascade (first p))
	(cascade-eval-node cascade (1- (cascade-nunits cascade)))
	(cascade-eval-output cascade)
	(setf (svref values-cache i)
	      (list (copy (cascade-values cascade))
		    (second p)))
	(setf (svref errors-cache i)
	      (m- (copy (second p))
		  (cascade-outputs cascade)))))
    (flet ((slopes-fn (w i)
	     (declare (ignore w))
	     (cascade-compute-cand-slopes-c2-for-pattern cascade cand out-cand conns i values-cache errors-cache params))
	   (delete-fn (idx)
	     (multiple-value-bind (-cand -conns)
		 (cascade-prune-cand-connection cascade (aref conns idx) cand conns)
	       (setf cand -cand conns -conns))))
      (values 
	(if (eq (param params :hess-method) :diag)
	    (obd #'(lambda () (cascade-compute-cand-hess-diag
			       cascade cand out-cand conns values-cache errors-cache params))
		 #'(lambda () cand) #'delete-fn values-cache params)
	    (obs (if (eq (param params :hess-method) :direct)
		     #'(lambda () (cascade-compute-cand-inv-hessian cascade values-cache params))
		     #'slopes-fn)
		 #'(lambda () cand) #'delete-fn values-cache
		 (setf (param (copy-tree params) :prune-limit) (- (cascade-nunits cascade) 2))))
	(concatenate '(simple-array single-float (*)) cand out-cand)
	conns))))
