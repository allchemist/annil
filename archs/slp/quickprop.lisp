(in-package :annil)

(defun quickprop-sse-train
 (weights patterns act-fn iter init-params)
  (let ((delta-weights (make-matrix-like weights))
	(slopes (make-matrix-like weights))
	(prev-slopes (make-matrix-like weights))

	(out (make-matrix (patterns-output-dim patterns)))
	(lgrad (make-matrix (patterns-output-dim patterns)))
	(prev-err 0)
	(epoch-err 0)
	(params (copy-tree init-params))
;	(recompute-limit (param init-params :recompute))
	(num-patterns (num-patterns patterns))
	(act-fn-deriv (deriv-fn-name act-fn)))
    (dotimes (i iter)
      (let* ((eps (/ (param params :epsilon) num-patterns (patterns-input-dim patterns)))
	     (mu (param params :mu))
	     (shrink-factor (/ mu (1+ mu))))
	(do-patterns-shuffle (patterns p)
	  (map-matrix (gemv weights (first p) :dest out) act-fn)
	  (m- (copy out lgrad) (second p))
	  (incf epoch-err (msum (map-matrix-square (copy lgrad))))
	  (m* lgrad (map-matrix out act-fn-deriv))
	  (ger lgrad (first p) :dest slopes)
	  
	  (map-three-matrices delta-weights slopes prev-slopes
			      #'(lambda (d s ps)
				  (let ((step 0.0))
;				    (when (< (* d s) 0)
;				      (decf step (* eps s)))
;				    (if (< (* d (- s (* shrink-factor ps))) 0)
;					(incf step (* mu d))
;					(incf step (* (/ s (- ps s)) d)))
				    (cond ((minusp d)
					   (when (plusp s)
					     (decf step (* eps s))) 
					   (if (>= s (* shrink-factor ps))
					       (incf step (* mu d))
					       (incf step (* d (/ s (- ps s))))))
					  ((plusp d)
					   (when (minusp s)
					     (decf step (* eps s)))
					   (if (<= s (* shrink-factor ps))
					       (incf step (* mu d))
					       (incf step (* d (/ s (- ps s))))))
					  (t (decf step (* eps s))))
				    step)))
	  (m+ weights delta-weights)
	  (copy slopes prev-slopes)
	  (m- slopes slopes))
	(setf prev-err (print (/ epoch-err num-patterns))
	      epoch-err 0)))
    weights))
